# Recursion

Recursive Function เป็นฟังก์ชันที่มีลักษณะพิเศษอย่างนึง คือตัวฟังก์ชันจะมีการอ้างอิงถึงตัวมันเอง (แต่ argument อาจเปลี่ยน) โดยเราสามารถแยกได้เป็นสองส่วน ดังนี้
- **Base Case** หมายถึง กรณีพื้นฐาน ฟังก์ชันส่วนนี้จะทำงานเป็นปกติ คือสามารถ return ค่าได้เลย
- **Recursive Step** หมายถึง กรณีที่อาจจะต้องเรียกฟังก์ชันตนเองซ้ำ (เปลี่ยน argument) ก่อนที่จะนำคำตอบมาประมวลผลแล้ว return ได้

## Factorial

ฟังก์ชัน factorial ในทางคณิตศาสตร์ ซึ่งมีนิยามไว้ว่า `n! = n * (n-1) * (n-2) * ... * 1`

จะได้ว่า
- `1! = 1`
- `2! = 2*1 = 2`
- `3! = 3*2*1 = 6`
- `4! = 4*3*2*1 = 24`
- `5! = 5*4*3*2*1 = 120`

ซึ่ง เราอาจสังเกตได้ว่า
- `2! = 2 * 1!`
- `3! = 3 * 2!`
- `4! = 4 * 3!`
- `5! = 5 * 4!`

กล่าวคือ `n! = n * (n-1)!` นั่นเอง

จากความรู้ตรงนี้ เราสามารถนำมาเขียนเป็นฟังก์ชัน Recursive ได้ทันที โดยลักษณะการเขียนจะเขียนเหมือนฟังก์ชันทั่วไปเลย ดังนี้

```cpp
int fact(int n) {
    // base case
    if (n == 1)
        return 1;
    // recursive step
    return n * fact(n-1);
}
```

โดยลักษณะการทำงาน
- เมื่อเราเรียก `fact(5)` ตัว `fact(5)` จะพยายามคำนวณ `fact(4)` ก่อน
- ในการคำนวณ `fact(4)` จะต้องคำนวณ `fact(3)` ก่อน
- ในการคำนวณ `fact(3)` จะต้องคำนวณ `fact(2)` ก่อน
- ในการคำนวณ `fact(2)` จะต้องคำนวณ `fact(1)` ก่อน
- `fact(1)` มีค่าเท่ากับ 1 พอดี จึงคืนค่า 1 กลับไป
- `fact(2)` จึงสามารถคืนค่า `2*fact(1) = 2*1 = 2` ได้
- `fact(3)` จึงสามารถคืนค่า `3*fact(2) = 3*2 = 6` ได้
- `fact(4)` จึงสามารถคืนค่า `4*fact(3) = 4*6 = 24` ได้
- `fact(5)` จึงสามารถคืนค่า `5*fact(4) = 5*24 = 120` ได้

## Fibonacci Sequence

ยกตัวอย่างอีกฟังก์ชันหนึ่ง คือฟังก์ชันสำหรับหาตัวเลขของลำดับฟีโบนักชี (Fibonacci sequence) ซึ่งนิยามไว้ดังนี้

- `F(1) = 1`
- `F(2) = 1`
- `F(n) = F(n-1) + F(n-2)`

กล่าวได้ว่า จำนวนฟีโบนักชีตัวที่ `n` คือผลรวมของจำนวนฟีโบนักชีสองตัวก่อนหน้า สังเกตได้ว่านิยามนี้มีความเป็น recursive function อยู่แล้ว เราสามารถแปลงเป็นโค้ดได้อย่างง่าย ดังนี้

```cpp
int fibo(int n) {
    // base case
    if (n == 1 || n == 2)
        return 1;
    // recursive step
    return fibo(n-1) + fibo(n-2);
}
```

การเรียกฟังก์ชัน Recursive จะต้องใช้เวลาและหน่วยความจำมากพอสมควร ดังนั้น หากสามารถเขียนฟังก์ชันโดยใช้ลูปแทนได้ ควรใช้ลูปแทน

## Tower of Hanoi

Recursive Function ไม่จำเป็นต้อง return ค่าเสมอไป แต่อาจจะเป็นการทำงานก็ได้ ยกตัวอย่างปัญหา Tower of Hanoi

มีเสาอยู่สามต้น และมีแผ่นจา่นอยู่ `n` ใบวางอยู่บนเสาแรก โดยชั้นล่างสุดเป็นจานแผ่นขนาดใหญ่สุด เรียงขึ้นมาขนาดเล็กลงเรื่อย ๆ ต้องการย้ายจานทั้งหมด `n` แผ่นไปยังเสาสุดท้าย โดยมีเงื่อนไขดังต่อไปนี้

- ย้ายได้ทีละใบเท่านั้น โดยต้องย้ายไปวางไว้ที่เสาใดเสาหนึ่งเท่านั้น
- ห้ามวางจานขนาดใหญ่กว่าทับจานขนาดเล็กกว่า

ในการแก้ปัญหา มีวิธีสังเกตง่าย ๆ ดังนี้

สมมุติว่าเราต้องการจะย้ายจาน `n` แผ่นจากเสา `A` ไปยังเสา `C` โดยมีเสา `B` เป็นตัวช่วย เราจะต้อง

- ย้ายจาน `n-1` แผ่นที่อยู่ข้างบน จาก `A` ไป `B` (มีเสา `C` เป็นตัวช่วย)
- ย้ายจานแผ่นสุดท้าย (แผ่นที่ `n` แผ่นเดียว) จากเสา `A` ไปยังเสา `C`
- ย้ายจาน `n-1` แผ่นจาก `B` ไป `C` (มีเสา `A` เป็นตัวช่วย)

สังเกตว่า การย้ายจาน `n-1` แผ่นเป็นปัญหาย่อยที่ใช้กระบวนการแก้ปัญหาแบบเดียวกัน ดังนั้นการแก้ปัญหา Tower of Hanoi จึงสามารถเขียนเป็น Recursive Function ได้

```cpp
#include <stdio.h>
// a = from, c = to, b = help
void solve(int n, char a, char c, char b) {
    if (n == 1) {
        printf("move from %c to %c\n", a, c);
    } else {
        solve(n-1, a, b, c); // move n-1 from a to b
        solve(1, a, c, b); // move last one from a to c
        solve(n-1, b, c, a); // move n-1 from b to c
    }
}
int main() {
    int n;
    scanf("%d", &n);
    solve(n, 'a', 'b', 'c');
    return 0;
}
```

## สรุปหลักการแก้ปัญหาแบบ Recursive

สำหรับการแก้ปัญหาโดยใช้ Recursive Function เราไม่ควรพยายามคิดเจาะรายละเอียดของลำดับการเรียกฟังก์ชันมากเกินไป เพราะอาจทำให้ไม่สามารถแก้ปัญหาได้ แต่ให้ยึดหลักดังนี้

- ให้สมมุติว่าฟังก์ชันเราสามารถแก้ปัญหาย่อยได้ถูกต้องทุกกรณี ไม่ต้องกังวลว่ากระบวนการแก้ปัญหาย่อยจะผิด
- สนใจแค่ว่า ถ้าปัญหาย่อยถูกทั้งหมด กระบวนการนี้จะแก้ปัญหาใหญ่ได้ถูกต้องหรือไม่
- argument ในการเรียกฟังก์ชันซ้ำจะต้องทำให้ปัญหาเล็กลงตลอด ต้องไม่วนซ้ำอยู่กับที่
- อย่าลืมระบุ Base Case เป็นกรณีพื้นฐานที่หยุดการเรียกซ้ำ

