# Function

โครงสร้างพื้นฐานอย่างหนึ่งของการเขียนโปรแกรมที่ควรจะรู้จักก็คือฟังก์ชัน (Function) หลาย ๆ คนอาจจะเคยใช้มาแล้ว แต่ไม่รู้ด้วยซ้ำว่าเป็นฟังก์ชัน อย่างพวก `printf`, `scanf`, `floor`, `ceil` อะไรทำนองนี้

หลัก ๆ แล้วฟังก์ชันมีสองประเภท ดังนี้

## ฟังก์ชันที่ไม่มีการ return ค่า

ฟังก์ชันประเภทนี้ จะเรียกว่าเป็นการกำหนดรูปแบบการก็อป/วางโค้ดก็ว่าได้ ยกตัวอย่าง สมมุติว่าเราต้องการจะเขียนโปรแกรมที่ปรินท์สัญลักษณ์ `-` ติดกัน 100 ตัว เราอาจจะเขียนเป็นลูปได้ดังนี้

```cpp
for (int i = 0; i < 100; ++i)
    printf("%c", '-');
```

สมมุติว่า เราต้องการปรับเปลี่ยน ให้ปรินท์ `-` 100 ตัว ตามด้วย `*` อีก 200 ตัว และก็ตามด้วย `+` อีก 150 ตัว ก็ต้องเพิ่มแบบนี้

```cpp
for (int i = 0; i < 100; ++i)
    printf("%c", '-');
for (int i = 0; i < 200; ++i)
    printf("%c", '*');
for (int i = 0; i < 150; ++i)
    printf("%c", '+');
```

สังเกตว่ามีการใช้โค้ดซ้ำกันเยอะมาก ส่วนที่เปลี่ยนมีแค่ตัวเลขกับตัวอักษรเท่านั้น ในส่วนนี้เราสามารถใช้เรื่องฟังก์ชันมาแก้ปัญหาได้

ก่อนอื่น เราต้องนิยามฟังก์ชัน `repeat` ไว้ด้านนอกฟังก์ชัน `main` โดยมีรูปแบบการประกาศฟังก์ชันดังนี้

```cpp
void function_name(type1 arg1, type2 arg2, ...) {
    // whatever you want to do here
}
```

ในที่นี้ จะต้องประกาศ `repeat` แบบนี้

```cpp
void repeat(char c, int n) {
    for (int i = 0; i < n; ++i)
        printf("%c", c);
}
```

สังเกตว่า ตรง `(char c, int n)` เป็นการระบุว่าการใช้ฟังก์ชันนี้ จะต้องระบุตัวอักษร ตามด้วยจำนวน ซึ่งภายในฟังก์ชัน จะเรียกว่า `c` และ `n` ตามลำดับ เรียกว่า argument ของฟังก์ชัน (ในที่นี้ ฟังก์ชันกำหนดไว้ว่า จะลูปปรินท์ `c` ทั้งหมด `n` ครั้ง)

พอเรานิยามฟังก์ชันมา เราก็สามารถเรียกใช้ตามรูปแบบนี้ได้ทันที
```cpp
repeat('-', 100);
repeat('*', 200);
repeat('+', 150);
```

เห็นได้ว่า ฟังก์ชันแบบไม่ return ค่า มีลักษณะคล้ายการก็อปวางโค้ดจริง ๆ คือที่ไหนมี `repeat` ที่นั่นจะมีลูปปรินท์โดยอัตโนมัติ สิ่งที่เปลี่ยนจะมีแค่ตัวอักษร `c` กับจำนวนเต็ม `n` เท่านั้น

ยกตัวอย่างฟังก์ชันอื่น ๆ เช่นฟังก์ชันปรินท์รูปปีระมิด

```cpp
#include <stdio.h>
void print_pyramid(int n) {
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= i; ++j)
            printf("#");
        printf("\n");
    }
}
int main() {
    print_pyramid(3);
    printf("----------");
    print_pyramid(5);
    return 0;
}
```

เมื่อเปิดโปรแกรม ก็จะได้ผลลัพธ์ดังนี้
```
#
##
###
----------
#
##
###
####
#####
```

## ฟังก์ชันที่มีการ return ค่า

ฟังก์ชันแบบนี้ จะคล้ายกับฟังก์ชันในคณิตศาสตร์ คือเมื่อเรียกใช้แล้ว จะได้ผลลัพธ์ที่สามารถนำมาเก็บใส่ตัวแปร หรือคำนวณต่อได้ เช่น ฟังก์ชัน `round` (ปัดเศษ)

```cpp
double v = 4.2;
double ans = round(v) + 1;
```

สังเกตว่า ณ ตำแหน่งที่เขียนว่า `round(4.2)` ตัวโปรแกรมจะคำนวณ แล้วนำคำตอบที่ได้มาใส่แทนตรงนั้นทันที จะได้ว่า `ans = 4 + 1` นั่นเอง

ถึงอย่างไรก็ตาม ฟังก์ชันไม่จำเป็นต้อง return ผลลัพธ์เป็นตัวเลขเสมอไป อาจจะ return เป็นอย่างอื่น เช่นตัวอักษรก็ได้

```cpp
printf("%c", toupper('a'));
```

ในที่นี้ จะได้ผลลัพธ์เหมือนกับ

```cpp
printf("%c", 'A');
```

สังเกตได้ว่า `toupper` เป็นฟังก์ชันที่รับตัวอักษร แล้วให้ผลลัพธ์เป็นตัวอักษรพิมพ์ใหญ่

ในการประกาศฟังก์ชันที่ return ค่าได้ จะมีรูปแบบการประกาศดังนี้

```cpp
type function_name(type1 arg1, type2 arg2, ...) {
    // whatever you want to do here
}
```

แต่ภายในฟังก์ชัน จะต้องมีการ return คำตอบด้วย โดยเขียนว่า `return your_answer_here;` ยกตัวอย่าง การประกาศฟังก์ชันเพื่อคำนวณระยะห่างระหว่างจุด `(x1, y1)` กับ `(x2, y2)`

```cpp
double distance(double x1, double y1, double x2, double y2) {
    double dx = x1-x2;
    double dy = y1-y2;
    double ans = sqrt(dx*dx + dy*dy);
    return ans;
}
```

ในที่นี้ จะเห็นได้ว่า `distance` เป็นฟังก์ชันที่รับจำนวนจริง `x1`, `y1`, `x2`, `y2` ตามลำดับ แล้วทำการคำนวณผลลัพธ์ออกมา ได้เป้นจำนวนจริงเช่นกัน

เมื่อต้องการจะเรียกใช้ สามารถเรียกใช้แล้วนำคำตอบที่ได้มาเก็บใส่ตัวแปร หรือนำไปคำนวณต่อได้ทันที

```cpp
double d1 = distance(1, 2, 3, 4);
double d2 = distance(1, 2, 3, 4) + 10.0;
```

## Prototype

ในภาษา C/C++ ตัว compiler จะอ่านจากบนลงล่างเสมอ เพราะฉะนั้น หากเราประกาศฟังก์ชันไว้ด้านล่าง `main` โปรแกรมจะคอมไพล์ไม่ผ่าน เพราะ `main` เรียกใช้ฟังก์ชัน แต่ด้านบน `main` ไม่ได้นิยามฟังก์ชันนั้นไว้

แก้ปัญหาได้โดยประกาศ prototype ของฟังก์ชันก่อนฟังก์ชัน `main` วิธีการง่าย ๆ คือการก็อปแค่หัวฟังก์ชันมา แล้วใส่เครื่องหมาย semicolon (`;`) ปิดท้าย ดังนี้

```cpp
#include <stdio.h>
#include <math.h>
// prototype
double distance(double x1, double y1, double x2, double y2);
// main function
int main() {
    double d1 = distance(1, 2, 3, 4);
    double d2 = distance(1, 2, 3, 4) + 10.0;
}
// actual function declaration
double distance(double x1, double y1, double x2, double y2) {
    double dx = x1-x2;
    double dy = y1-y2;
    double ans = sqrt(dx*dx + dy*dy);
    return ans;
}
```

อนึ่ง สามารถย่อ prototype ให้สั้นลงได้ โดยตัดชื่อตัวแปรใน prototype ออก เหลือแค่ชนิดตัวแปร ดังนี้

```cpp
double distance(double, double, double, double);
```

## Pass by Value vs. Pass by Reference

สมมุติว่าเราต้องการเขียนฟังก์ชันเพื่อสลับตัวแปร ดังนี้

```cpp
void swap(int x, int y) {
    int t = x;
    x = y;
    y = t;
}
```

แล้วนำมาทดลอง ดังนี้

```cpp
int x = 1;
int y = 2;
swap(x, y);
printf("%d %d", x, y);
```

เราจะได้ผลลัพธ์เป็น `1 2` ทั้ง ๆ ที่คำตอบน่าจะสลับเป็น `2 1`

ทั้งนี้ เป็นเพราะการเรียกฟังก์ชัน ข้อมูลในตัวแปรทั้งหมดจะถูกคัดลอกไปให้ฟังก์ชัน ดังนั้น ถึงแม้ฟังก์ชันจะเปลี่ยนแปลงค่าของตัวแปรอย่างไรก็ตาม ก็จะไม่มีผลกับตัวแปรเดิม การส่งตัวแปรโดยการคัดลอกแบบนี้ เรียกว่า Pass by Value

หากต้องการจะแก้ปัญหานี้ เราจะต้องส่งที่อยู่ของตัวแปรให้ฟังก์ชันแทน (pointer) ฟังก์ชันจึงจะสามารถเปลี่ยนค่าของตัวแปร ณ ที่อยู่ที่กำหนดให้ได้ ดังนี้

```cpp
#include <stdio.h>
void swap(int *x, int *y) {
    int t = *x;
    *x = *y;
    *y = t;
}
int main() {
    int x = 1, y = 2;
    swap(&x, &y);
    pritnf("%d %d", x, y); // 2 1
    return 0;
}
```

สัญลักษณ์ `&x` หมายถึง ที่อยู่ของตัวแปร `x` ส่วน `*x` หมายถึงค่า ณ ตำแหน่ง `x` (ควรศึกษาเรื่อง Pointer)

การส่ง pointer ให้แทนที่จะส่งค่าของตัวแปรให้โดยตรงแบบนี้ เรียกว่า Pass by Reference

## การ return ค่าผ่าน pointer

วิธี Pass by Reference สามารถใช้เพื่อ return ผลลัพธ์หลายผลลัพธ์ได้ โดย pointer ที่ส่งให้ฟังก์ชัน จะชี้ตำแหน่งตัวแปรที่ต้องการให้เปลี่ยน เพื่อเก็บเป็นคำตอบ

ยกตัวอย่างเช่น ฟังก์ชันที่รับจุด `(x1, y1)` และ `(x2, y2)` มา แล้วตอบว่าพิกัดในแกน X และแกน Y มีค่าต่างกันเท่าไหร่ สามารถนิยามฟังก์ชันได้ดังนี้

```cpp
void distance(double x1, double x2, double y1, double y2, double *dx, double *dy) {
    *dx = abs(x1-x2);
    *dy = abs(y1-y2);
}
```

สังเกตว่าฟังก์ชันนี้จะไม่ return ค่าโดยตรง แต่จะเปลี่ยนค่าของตัวแปร ตามที่อยู่ `dx` และ `dy` ที่กำหนดให้แทน โดยเราอาจจะเรียกใช้ฟังก์ชัน `distance` ได้ดังนี้

```cpp
double dist_x, dist_y;
distance(1, 2, 3, 4, &dist_x, &dist_y);
printf("%f %f", dist_x, dist_y);
```

เห็นได้ว่า คำตอบที่ได้รับจะถูกเก็บไว้ในตัวแปร `dist_x` และ `dist_y` ที่ตั้งขึ้น เพราะเราส่งที่อยู่ของตัวแปร `dist_x` และ `dist_y` ให้ฟังก์ชัน `distance`

## Array กับฟังก์ชัน

ในการรับ array ควรจะรับขนาดของ array มาด้วย เราไม่สามารถหาขนาดของ array โดยการใช้ `sizeof` ได้ เนื่องจากภาษา C/C++ จะลดรูป array ให้กลายเป็น pointer โดยอัตโนมัติเมื่อส่งมาเป็น argument ของฟังก์ชัน

```cpp
void print_students(int studentID[], int n)
{
    // can't use
    // n = sizeof(studentID) / sizeof(int);
    for (int i = 0; i < n; i++)
        printf("Student #%d: ID %d\n", i+1, studentID[i]);
}
```

หากต้องการจะ return คำตอบเป็น array จะต้อง `malloc` หน่วยความจำแล้ว return pointer ของ array นั้นแทน หรือมิเช่นนั้น ก็จะต้องกำหนด array คำตอบเปล่า ๆ มาให้ฟังก์ชันแก้ไขเพื่อจดเป็นคำตอบ (คล้ายการ return ค่าผ่าน pointer)